<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>現代化報告地圖可視化</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Roboto", sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f0f0f0;
        color: #333;
      }
      .container {
        max-width: 1000px;
        margin: 0 auto;
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      canvas {
        border: none;
        display: block;
        margin: 20px auto;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      h1,
      h2 {
        text-align: center;
        color: #2c3e50;
      }
      h1 {
        margin-bottom: 10px;
      }
      h2 {
        font-weight: 300;
        margin-top: 0;
      }
      #legend {
        display: flex;
        justify-content: center;
        margin-top: 20px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin: 0 10px;
      }

      .color-box {
        width: 20px;
        height: 20px;
        margin-right: 5px;
        border-radius: 4px;
      }

      .info-box {
        display: none;
        border: 1px solid #ccc;
        padding: 10px;
        position: absolute;
        background: white;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        max-width: 300px;
      }

      .info-box h3 {
        margin-top: 0;
        color: #2c3e50;
      }

      .risk-level {
        padding: 2px 6px;
        border-radius: 4px;
        color: white;
        font-weight: bold;
      }

      .risk-level.malicious {
        background-color: #e74c3c;
      }
      .risk-level.suspicious {
        background-color: #f39c12;
      }
      .risk-level.safe {
        background-color: #2ecc71;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>現代化報告地圖可視化</h1>
      <h2>視覺化報告數據</h2>
      <canvas id="mapCanvas" width="800" height="800" style="border:1px solid #000000;"></canvas>
      <div id="legend"></div>
    </div>

    <div id="infoBox" class="info-box"></div>

    <script>
      const apiKey = "AIzaSyB-VS32a91Wy2xwAMhDD4BFUSu6YPwneuo";
      const spreadsheetId = "1gCXrchthcYSjBcB6hBSg3ujOVoptPVukivNwPNk8TNQ";

      // 在文件頂部定義全局變量
      let headers = [];
      let reportData = [];

      // 首先獲取表格元數據
      function getSheetMetadata() {
        const metadataUrl = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}?fields=sheets.properties&key=${apiKey}`;

        return fetch(metadataUrl)
          .then((response) => response.json())
          .then((data) => {
            const sheet = data.sheets[0]; // 假設我們使用第一個工作表
            return sheet.properties.gridProperties.rowCount;
          });
      }

      // 然後使用元數據來獲取數據
      function fetchDataAndDrawMap() {
        const range = "sheet1!A:I";
        const url = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${range}?key=${apiKey}`;

        fetch(url)
          .then((response) => response.json())
          .then((data) => {
            console.log("獲取的數據:", data);
            if (!data || !data.values || data.values.length < 2) {
              console.error("獲取的數據為空或格式不正確");
              return;
            }
            headers = data.values[0]; // 設置全局 headers
            reportData = data.values.slice(1); // 設置全局 reportData
            drawMap();
          })
          .catch((error) => console.error("獲取數據時出錯:", error));
      }

      const usedCoordinates = new Set();
      const plotPositions = {};
      const gridSize = 20;
      const canvasWidth = 800;
      const canvasHeight = 800;
      const adjacentOffset = [
        [1, 0],
        [-1, 0],
        [0, 1],
        [0, -1],
      ];

      function drawMap() {
        console.log("使用以下數據繪製地圖:", reportData);
        
        const canvas = document.getElementById("mapCanvas");
        const ctx = canvas.getContext("2d");

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const urlCounts = {};
        const urlPositions = {};
        const newCoordinates = [];

        reportData.forEach((report, index) => {
          const UID = report[headers.indexOf("UID")] || "";
          const ID = report[headers.indexOf("ID")] || "";
          const URL = report[headers.indexOf("URL")] || "";
          const riskLevel = report[headers.indexOf("Risk Level")] || "Unknown";
          let coordinates = report[headers.indexOf("Coordinates")];

          urlCounts[URL] = (urlCounts[URL] || 0) + 1;

          let position;
          if (coordinates && coordinates.match(/\d+,\d+/)) {
            const [x, y] = coordinates.match(/\d+/g).map(Number);
            position = [x * gridSize, y * gridSize];
          } else {
            if (urlPositions[URL]) {
              // 如果該 URL 已有位置，在周圍生成新位置
              position = findAdjacentPosition(urlPositions[URL]);
            } else {
              // 如果是新 URL，隨機生成不相鄰的位置
              position = findRandomPosition();
              urlPositions[URL] = position;
            }
            coordinates = `(${Math.floor(position[0] / gridSize)},${Math.floor(position[1] / gridSize)})`;
            newCoordinates.push({ index: index + 1, coordinates }); // +1 因為 reportData 不包含表頭
          }

          const [x, y] = position;
          usedCoordinates.add(`${x},${y}`);

          drawBlock(ctx, x, y, riskLevel, urlCounts[URL] > 1);
          drawText(ctx, UID, x, y);

          // 更新 reportData 中的座標
          report[headers.indexOf("Coordinates")] = coordinates;
        });

        // 為多個報告的 URL 繪製邊框
        Object.entries(urlCounts).forEach(([url, count]) => {
          if (count > 1) {
            drawBorder(ctx, url);
          }
        });

        addClickListener(canvas);

        // 如果有新生成的座標,將它們更新到 Google Sheets
        if (newCoordinates.length > 0) {
          updateGoogleSheets(newCoordinates);
        }
      }

      function findAdjacentPosition(basePosition) {
        const [baseX, baseY] = basePosition;
        const adjacentOffsets = [[0, -1], [1, 0], [0, 1], [-1, 0]]; // 上、右、下、左
        
        for (let [offsetX, offsetY] of adjacentOffsets) {
          const newX = baseX + offsetX * gridSize;
          const newY = baseY + offsetY * gridSize;
          if (!usedCoordinates.has(`${newX},${newY}`)) {
            return [newX, newY];
          }
        }
        
        // 如果所有相鄰位置都被佔用，則隨機生成一個新位置
        return findRandomPosition();
      }

      function findRandomPosition() {
        let position;
        do {
          position = [
            Math.floor(Math.random() * (canvasWidth / gridSize)) * gridSize,
            Math.floor(Math.random() * (canvasHeight / gridSize)) * gridSize,
          ];
        } while (isPositionUsedOrOutOfBounds(position));
        return position;
      }

      function isPositionUsedOrOutOfBounds([x, y]) {
        return (
          usedCoordinates.has(`${x},${y}`) ||
          x < 0 ||
          y < 0 ||
          x >= canvasWidth ||
          y >= canvasHeight
        );
      }

      function drawBlock(ctx, x, y, riskLevel, hasMultipleReports) {
        ctx.fillStyle = getRiskColor(riskLevel);
        ctx.fillRect(x, y, gridSize, gridSize);

        if (hasMultipleReports) {
          ctx.strokeStyle = "#3498db";
          ctx.lineWidth = 3;
          ctx.strokeRect(x, y, gridSize, gridSize);
        }

        // 添加陰影效果
        ctx.shadowColor = "rgba(0, 0, 0, 0.2)";
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
      }

      function getRiskColor(riskLevel) {
        switch (riskLevel) {
          case "Malicious":
            return "#e74c3c";
          case "Suspicious":
            return "#f39c12";
          case "Safe":
            return "#2ecc71";
          default:
            return "#95a5a6";
        }
      }

      function drawText(ctx, text, x, y) {
        ctx.fillStyle = "black";
        ctx.font = "10px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, x + gridSize / 2, y + gridSize / 2);
      }

      function addClickListener(canvas) {
        canvas.addEventListener("click", function(event) {
          const rect = canvas.getBoundingClientRect();
          const mouseX = event.clientX - rect.left;
          const mouseY = event.clientY - rect.top;

          const clickedReport = reportData.find(report => {
            const coordinates = report[headers.indexOf("Coordinates")];
            if (coordinates) {
              const [x, y] = coordinates.match(/\d+/g).map(Number);
              return mouseX >= x * gridSize && mouseX < (x + 1) * gridSize &&
                     mouseY >= y * gridSize && mouseY < (y + 1) * gridSize;
            }
            return false;
          });

          if (clickedReport) {
            console.log("點擊的報告:", clickedReport);
            showInfoBox(clickedReport, event.pageX, event.pageY);
          } else {
            console.log("在點擊位置未找到報告");
          }
        });
      }

      function showInfoBox(report, x, y) {
        const infoBox = document.getElementById("infoBox");
        infoBox.style.left = `${x + 10}px`;
        infoBox.style.top = `${y + 10}px`;
        infoBox.style.display = "block";
        infoBox.innerHTML = `
          <h3>報告詳情</h3>
          <p><strong>UID:</strong> ${report[headers.indexOf("UID")] || '無'}</p>
          <p><strong>ID:</strong> ${report[headers.indexOf("ID")] || '無'}</p>
          <p><strong>URL:</strong> ${report[headers.indexOf("URL")] || '無'}</p>
          <p><strong>風險等級:</strong> <span class="risk-level ${(report[headers.indexOf("Risk Level")] || 'unknown').toLowerCase()}">${report[headers.indexOf("Risk Level")] || 'Unknown'}</span></p>
          <p><strong>類別:</strong> ${report[headers.indexOf("Categories")] || '無'}</p>
          <p><strong>惡意/可疑原因:</strong> ${report[headers.indexOf("Reason of Malicious / Suspicious")] || '無'}</p>
          <p><strong>詐騙原因:</strong> ${report[headers.indexOf("Scam Reason")] || '無'}</p>
          <p><strong>描述:</strong> ${report[headers.indexOf("Row Message")] || '無'}</p>
          <p><strong>座標:</strong> ${report[headers.indexOf("Coordinates")] || '無'}</p>
        `;
      }

      function createLegend() {
        const legend = document.getElementById("legend");
        const riskLevels = ["Malicious", "Suspicious", "Safe", "Unknown"];

        legend.innerHTML = "<h3>風險等級</h3>";
        riskLevels.forEach((level) => {
          const item = document.createElement("div");
          item.className = "legend-item";
          item.innerHTML = `
            <span class="color-box" style="background-color: ${getRiskColor(
              level
            )}"></span>
            <span>${level}</span>
          `;
          legend.appendChild(item);
        });
      }

      document.addEventListener("DOMContentLoaded", fetchDataAndDrawMap);

      createLegend();

      function updateGoogleSheets(newCoordinates) {
        const batchUpdateUrl = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;
        const requests = newCoordinates.map(({ index, coordinates }) => ({
          updateCells: {
            range: {
              sheetId: 0, // 假設我們使用第一個工作表
              startRowIndex: index,
              endRowIndex: index + 1,
              startColumnIndex: headers.indexOf("Coordinates"),
              endColumnIndex: headers.indexOf("Coordinates") + 1
            },
            rows: [{ values: [{ userEnteredValue: { stringValue: coordinates } }] }],
            fields: "userEnteredValue"
          }
        }));

        fetch(batchUpdateUrl, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${accessToken}`, // 需要 OAuth 2.0 訪問令牌
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ requests })
        })
        .then(response => response.json())
        .then(result => console.log('成功更新 Google Sheets:', result))
        .catch(error => console.error('更新 Google Sheets 時出錯:', error));
      }

      function drawBorder(ctx, url) {
        const positions = reportData
          .filter(report => report[headers.indexOf("URL")] === url)
          .map(report => {
            const coordinates = report[headers.indexOf("Coordinates")];
            const [x, y] = coordinates.match(/\d+/g).map(Number);
            return [x * gridSize, y * gridSize];
          });

        ctx.strokeStyle = "#3498db";
        ctx.lineWidth = 2;
        ctx.beginPath();
        positions.forEach(([x, y], index) => {
          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.closePath();
        ctx.stroke();
      }
    </script>
  </body>
</html>
